package pk.lucidxpo.ynami.persistence.model;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.Id;
import jakarta.persistence.MappedSuperclass;
import lombok.Data;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

import static org.hibernate.annotations.SourceType.DB;
import static pk.lucidxpo.ynami.utils.Identity.randomID;

@Data
@MappedSuperclass
@EntityListeners({AuditingEntityListener.class})
public abstract class Auditable<U> implements Identifiable {
    //    TODO: consider replacing this class with org.springframework.data.jpa.domain.AbstractAuditable
    @Id
    @Column(nullable = false, updatable = false)
    private String id = randomID();

    // The @CreatedDate and @CreationTimestamp are convenient annotation which sets the field value to the current
    // timestamp when the entity is first saved. @CreatedDate is a Spring annotation. It is applicable to all stores
    // covered by Spring Data: JPA, JDBC, R2DBC, MongoDb, Cassandra and so on, whereas @CreationTimestamp is a Hibernate
    // annotation. It is applicable to Hibernate only. By default, both of these annotations use the current date of
    // the Java Virtual Machine when setting property values. Starting from Hibernate 6.0.0, we can optionally specify
    // the database as the source of the date. However, when using @CreationTimestamp and @UpdateTimestamp, we have to
    // keep in mind that Hibernate generates new timestamps on a per-field basis. This leads to multiple timestamps
    // being different, even though they were set by the same INSERT or UPDATE statement. Main reason to use the
    // @CreationTimestamp instead of @CreatedDate is, Spring Data Jpa sets the creation timestamp with nanoseconds
    // (9 digits) precision on java object but saves the object with microseconds (6 digits) precision in the database
    // on linux machines (this issue doesn't happen on MAC) and hence the assertions in the integration tests fail
    // due to difference in precisions. So, setting 'source = DB' on the @CreationTimestamp annotation helps resolve
    // this issue and tests work on both Mac and Linux.
    // Insertable => Whether the column is included in SQL INSERT statements generated by the persistence provider.
    // Updatable => Whether the column is included in SQL UPDATE statements generated by the persistence provider.
    @CreationTimestamp(source = DB)
    @Column(nullable = false, insertable = false, updatable = false)
    private Instant createdDate;

    // The @LastModifiedDate and @UpdateTimestamp are convenient annotation which automatically sets the field value to
    // the current timestamp on each entity update. @LastModifiedDate is a Spring annotation. It is applicable to all
    // stores covered by Spring Data: JPA, JDBC, R2DBC, MongoDb, Cassandra and so on, whereas @UpdateTimestamp is a
    // Hibernate annotation. It is applicable to Hibernate only.By default, both of these annotations use the current
    // date of the Java Virtual Machine when setting property values. Starting from Hibernate 6.0.0, we can optionally
    // specify the database as the source of the date. Main reason to use the @UpdateTimestamp instead of
    // @LastModifiedDate is, Spring Data Jpa sets the updation timestamp with nanoseconds (9 digits) precision on java
    // object but saves the object with microseconds (6 digits) precision in the database on linux machines (this issue
    // doesn't happen on MAC) and hence the assertions in the integration tests fail due to difference in precisions.
    // So, setting 'source = DB' on the @UpdateTimestamp annotation helps resolve this issue and tests work on both Mac
    // and Linux.
    // Insertable => Whether the column is included in SQL INSERT statements generated by the persistence provider.
    // Updatable => Whether the column is included in SQL UPDATE statements generated by the persistence provider.
    @UpdateTimestamp(source = DB)
    @Column(insertable = false, updatable = false)
    private Instant lastModifiedDate;

    //    @ManyToOne
    @CreatedBy
    @Column(nullable = false, updatable = false)
    private U createdBy;

    @Column(nullable = false)
//    @ManyToOne
    @LastModifiedBy
    private U lastModifiedBy;
}